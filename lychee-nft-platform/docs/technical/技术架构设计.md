# 钜园农业恐龙蛋荔枝NFT/RWA预售平台技术架构设计

## 1. 系统架构概述

### 1.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用      │    │   后端API       │    │   区块链网络    │
│   (Next.js)     │◄──►│   (Node.js)     │◄──►│   (Polygon)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面      │    │   数据库        │    │   智能合约      │
│   (React)       │    │   (PostgreSQL)  │    │   (Solidity)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.2 技术选型

#### 前端技术栈
- **框架**: Next.js 14 (React 18)
- **语言**: TypeScript
- **样式**: Tailwind CSS
- **状态管理**: Zustand
- **数据获取**: TanStack Query
- **钱包集成**: WalletConnect v2
- **UI组件**: Radix UI

#### 后端技术栈
- **运行时**: Node.js 18
- **框架**: Express.js
- **语言**: TypeScript
- **数据库**: PostgreSQL 15
- **缓存**: Redis 7
- **队列**: Bull Queue
- **认证**: JWT + OAuth2

#### 区块链技术栈
- **网络**: Polygon (主网)
- **备用**: Arbitrum One
- **RPC**: Alchemy/Infura
- **索引**: The Graph
- **存储**: IPFS (Pinata)

## 2. 智能合约设计

### 2.1 核心合约架构

#### DragonEggLycheeNFT 合约
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract DragonEggLycheeNFT is ERC721, Ownable, ReentrancyGuard {
    // 荔枝批次信息
    struct LycheeBatch {
        uint256 batchId;
        string origin;           // 产地
        uint256 harvestDate;     // 收获日期
        uint256 totalQuantity;   // 总数量
        uint256 soldQuantity;    // 已售数量
        uint256 pricePerKg;      // 每公斤价格
        address farmer;          // 农户地址
        bool isActive;           // 是否激活
        string ipfsHash;         // IPFS存储哈希
    }
    
    // 用户订单信息
    struct UserOrder {
        uint256 orderId;
        address buyer;
        uint256 quantity;
        uint256 totalPrice;
        uint256 orderTime;
        bool isDelivered;
        string trackingNumber;
    }
    
    // 状态变量
    mapping(uint256 => LycheeBatch) public batches;
    mapping(uint256 => UserOrder) public orders;
    mapping(address => uint256[]) public userOrders;
    
    uint256 public nextBatchId = 1;
    uint256 public nextOrderId = 1;
    uint256 public platformFee = 250; // 2.5%
    
    // 事件定义
    event BatchCreated(uint256 indexed batchId, string origin, uint256 quantity, uint256 price);
    event OrderPlaced(uint256 indexed orderId, address indexed buyer, uint256 quantity);
    event OrderDelivered(uint256 indexed orderId, string trackingNumber);
    event ProfitDistributed(uint256 amount);
    
    // 创建荔枝批次
    function createBatch(
        string memory _origin,
        uint256 _harvestDate,
        uint256 _totalQuantity,
        uint256 _pricePerKg,
        address _farmer,
        string memory _ipfsHash
    ) external onlyOwner {
        uint256 batchId = nextBatchId++;
        batches[batchId] = LycheeBatch({
            batchId: batchId,
            origin: _origin,
            harvestDate: _harvestDate,
            totalQuantity: _totalQuantity,
            soldQuantity: 0,
            pricePerKg: _pricePerKg,
            farmer: _farmer,
            isActive: true,
            ipfsHash: _ipfsHash
        });
        
        emit BatchCreated(batchId, _origin, _totalQuantity, _pricePerKg);
    }
    
    // 购买荔枝NFT
    function purchaseLychee(
        uint256 _batchId,
        uint256 _quantity
    ) external payable nonReentrant {
        require(batches[_batchId].isActive, "Batch not active");
        require(_quantity > 0, "Quantity must be positive");
        require(batches[_batchId].soldQuantity + _quantity <= batches[_batchId].totalQuantity, "Insufficient quantity");
        
        uint256 totalPrice = _quantity * batches[_batchId].pricePerKg;
        uint256 fee = (totalPrice * platformFee) / 10000;
        uint256 netPrice = totalPrice - fee;
        
        require(msg.value >= totalPrice, "Insufficient payment");
        
        // 更新批次信息
        batches[_batchId].soldQuantity += _quantity;
        
        // 创建订单
        uint256 orderId = nextOrderId++;
        orders[orderId] = UserOrder({
            orderId: orderId,
            buyer: msg.sender,
            quantity: _quantity,
            totalPrice: totalPrice,
            orderTime: block.timestamp,
            isDelivered: false,
            trackingNumber: ""
        });
        
        userOrders[msg.sender].push(orderId);
        
        // 铸造NFT
        _safeMint(msg.sender, orderId);
        
        // 转账给农户
        payable(batches[_batchId].farmer).transfer(netPrice);
        
        emit OrderPlaced(orderId, msg.sender, _quantity);
        
        // 退款多余金额
        if (msg.value > totalPrice) {
            payable(msg.sender).transfer(msg.value - totalPrice);
        }
    }
    
    // 确认交付
    function confirmDelivery(
        uint256 _orderId,
        string memory _trackingNumber
    ) external onlyOwner {
        require(orders[_orderId].orderId != 0, "Order not found");
        require(!orders[_orderId].isDelivered, "Already delivered");
        
        orders[_orderId].isDelivered = true;
        orders[_orderId].trackingNumber = _trackingNumber;
        
        emit OrderDelivered(_orderId, _trackingNumber);
    }
    
    // 分发平台收益
    function distributeProfits() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No profits to distribute");
        
        // 50%给平台，50%给代币持有者
        uint256 platformShare = balance / 2;
        uint256 tokenHolderShare = balance - platformShare;
        
        // 转账给平台
        payable(owner()).transfer(platformShare);
        
        // 按比例分发给代币持有者
        // 这里需要实现代币持有者分红逻辑
        
        emit ProfitDistributed(balance);
    }
    
    // 获取用户订单
    function getUserOrders(address _user) external view returns (uint256[] memory) {
        return userOrders[_user];
    }
    
    // 获取批次信息
    function getBatchInfo(uint256 _batchId) external view returns (LycheeBatch memory) {
        return batches[_batchId];
    }
}
```

### 2.2 治理合约
```solidity
contract LycheeGovernance {
    struct Proposal {
        uint256 id;
        string description;
        uint256 votesFor;
        uint256 votesAgainst;
        uint256 deadline;
        bool executed;
    }
    
    mapping(uint256 => Proposal) public proposals;
    mapping(address => mapping(uint256 => bool)) public hasVoted;
    mapping(address => uint256) public votingPower;
    
    uint256 public nextProposalId = 1;
    uint256 public votingPeriod = 7 days;
    
    function createProposal(string memory _description) external {
        uint256 proposalId = nextProposalId++;
        proposals[proposalId] = Proposal({
            id: proposalId,
            description: _description,
            votesFor: 0,
            votesAgainst: 0,
            deadline: block.timestamp + votingPeriod,
            executed: false
        });
    }
    
    function vote(uint256 _proposalId, bool _support) external {
        require(!hasVoted[msg.sender][_proposalId], "Already voted");
        require(block.timestamp <= proposals[_proposalId].deadline, "Voting period ended");
        
        hasVoted[msg.sender][_proposalId] = true;
        
        if (_support) {
            proposals[_proposalId].votesFor += votingPower[msg.sender];
        } else {
            proposals[_proposalId].votesAgainst += votingPower[msg.sender];
        }
    }
}
```

## 3. 前端应用设计

### 3.1 核心页面结构

#### 首页组件
```tsx
const HomePage = () => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-green-50 to-yellow-50">
      {/* 英雄区域 */}
      <HeroSection />
      
      {/* 特色产品 */}
      <FeaturedProducts />
      
      {/* 数据统计 */}
      <StatsSection />
      
      {/* 用户评价 */}
      <TestimonialsSection />
      
      {/* 新闻动态 */}
      <NewsSection />
    </div>
  );
};
```

#### 产品详情页
```tsx
const ProductDetail = ({ batchId }: { batchId: string }) => {
  const { data: batch, isLoading } = useQuery({
    queryKey: ['batch', batchId],
    queryFn: () => fetchBatchDetails(batchId)
  });
  
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* 产品图片和视频 */}
        <ProductMedia batch={batch} />
        
        {/* 产品信息 */}
        <ProductInfo batch={batch} />
        
        {/* 购买区域 */}
        <PurchaseSection batch={batch} />
        
        {/* 溯源信息 */}
        <TraceabilitySection batch={batch} />
      </div>
    </div>
  );
};
```

### 3.2 状态管理
```typescript
// Zustand store
interface AppState {
  user: User | null;
  wallet: WalletState;
  orders: Order[];
  batches: Batch[];
  
  // Actions
  setUser: (user: User | null) => void;
  connectWallet: () => Promise<void>;
  disconnectWallet: () => void;
  fetchOrders: () => Promise<void>;
  fetchBatches: () => Promise<void>;
}

const useAppStore = create<AppState>((set, get) => ({
  user: null,
  wallet: { connected: false, address: null },
  orders: [],
  batches: [],
  
  setUser: (user) => set({ user }),
  connectWallet: async () => {
    // 钱包连接逻辑
  },
  disconnectWallet: () => set({ wallet: { connected: false, address: null } }),
  fetchOrders: async () => {
    // 获取订单数据
  },
  fetchBatches: async () => {
    // 获取批次数据
  }
}));
```

## 4. 后端API设计

### 4.1 API路由结构
```typescript
// API路由定义
const apiRoutes = {
  // 用户相关
  '/api/users': {
    'POST': 'createUser',
    'GET': 'getUser',
    'PUT': 'updateUser',
    'DELETE': 'deleteUser'
  },
  
  // 产品相关
  '/api/products': {
    'GET': 'getProducts',
    'POST': 'createProduct',
    'PUT': 'updateProduct'
  },
  
  // 订单相关
  '/api/orders': {
    'GET': 'getOrders',
    'POST': 'createOrder',
    'PUT': 'updateOrder'
  },
  
  // 区块链相关
  '/api/blockchain': {
    'POST': 'syncTransaction',
    'GET': 'getTransactionStatus'
  }
};
```

### 4.2 数据库设计
```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    wallet_address VARCHAR(42) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE,
    phone VARCHAR(20),
    kyc_status VARCHAR(20) DEFAULT 'pending',
    risk_level VARCHAR(10) DEFAULT 'medium',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 产品批次表
CREATE TABLE product_batches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    batch_id BIGINT UNIQUE NOT NULL,
    origin VARCHAR(100) NOT NULL,
    harvest_date DATE NOT NULL,
    total_quantity DECIMAL(10,2) NOT NULL,
    sold_quantity DECIMAL(10,2) DEFAULT 0,
    price_per_kg DECIMAL(10,2) NOT NULL,
    farmer_address VARCHAR(42) NOT NULL,
    ipfs_hash VARCHAR(100),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 订单表
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id BIGINT UNIQUE NOT NULL,
    user_id UUID REFERENCES users(id),
    batch_id UUID REFERENCES product_batches(id),
    quantity DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    tracking_number VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 交易记录表
CREATE TABLE transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tx_hash VARCHAR(66) UNIQUE NOT NULL,
    order_id UUID REFERENCES orders(id),
    from_address VARCHAR(42) NOT NULL,
    to_address VARCHAR(42) NOT NULL,
    amount DECIMAL(20,8) NOT NULL,
    gas_used BIGINT,
    gas_price BIGINT,
    block_number BIGINT,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW()
);
```

## 5. 部署架构

### 5.1 Docker配置
```yaml
# docker-compose.yml
version: '3.8'
services:
  # 前端服务
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:4000
      - NEXT_PUBLIC_SOLANA_RPC_URL=https://api.devnet.solana.com
    depends_on:
      - backend

  # 后端服务
  backend:
    build: ./backend
    ports:
      - "4000:4000"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/lychee_db
      - REDIS_URL=redis://redis:6379
      - NODE_ENV=production
    depends_on:
      - postgres
      - redis

  # 数据库
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=lychee_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  # 缓存
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"

volumes:
  postgres_data:
  redis_data:
```

### 5.2 Kubernetes配置
```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: lychee-frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: lychee-frontend
  template:
    metadata:
      labels:
        app: lychee-frontend
    spec:
      containers:
      - name: frontend
        image: lychee-frontend:latest
        ports:
        - containerPort: 3000
        env:
        - name: NEXT_PUBLIC_API_URL
          value: "https://api.lychee-nft.com"
---
apiVersion: v1
kind: Service
metadata:
  name: lychee-frontend-service
spec:
  selector:
    app: lychee-frontend
  ports:
  - port: 80
    targetPort: 3000
  type: LoadBalancer
```

## 6. 安全考虑

### 6.1 智能合约安全
- 使用OpenZeppelin标准库
- 实施重入攻击防护
- 进行全面的安全审计
- 使用多重签名机制

### 6.2 应用安全
- HTTPS强制使用
- JWT令牌认证
- 输入数据验证
- SQL注入防护
- XSS攻击防护

### 6.3 基础设施安全
- 防火墙配置
- DDoS防护
- 数据加密存储
- 定期安全更新
- 监控和告警

## 7. 性能优化

### 7.1 前端优化
- 代码分割和懒加载
- 图片优化和CDN
- 缓存策略
- 服务端渲染

### 7.2 后端优化
- 数据库索引优化
- Redis缓存
- API响应压缩
- 连接池管理

### 7.3 区块链优化
- Gas费用优化
- 批量交易处理
- 事件监听优化
- 数据同步策略

## 8. 监控和日志

### 8.1 应用监控
- 性能指标监控
- 错误率监控
- 用户行为分析
- 业务指标监控

### 8.2 基础设施监控
- 服务器资源监控
- 数据库性能监控
- 网络流量监控
- 安全事件监控

### 8.3 日志管理
- 结构化日志记录
- 日志聚合和分析
- 告警机制
- 日志保留策略
