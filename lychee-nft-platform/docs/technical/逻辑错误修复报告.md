# é€»è¾‘é”™è¯¯ä¿®å¤æŠ¥å‘Š

## ä¿®å¤æ¦‚è§ˆ

æœ¬æ¬¡ä¿®å¤é’ˆå¯¹ç³»ç»Ÿä¸­çš„å…³é”®é€»è¾‘æ¼æ´å’Œæ½œåœ¨å®‰å…¨é—®é¢˜ï¼Œç¡®ä¿ç³»ç»Ÿçš„å¥å£®æ€§å’Œå¯é æ€§ã€‚

**ä¿®å¤æ—¶é—´**: 2025-10-07  
**ä¿®å¤èŒƒå›´**: é¢„å”®æœåŠ¡ã€è®¢å•æœåŠ¡ã€æ‰˜ç®¡åˆçº¦  
**ä¿®å¤çº§åˆ«**: ğŸ”´ ä¸¥é‡ â†’ âœ… å·²ä¿®å¤

---

## ä¸€ã€é¢„å”®æœåŠ¡ä¿®å¤ (PresaleService)

### 1.1 åº“å­˜å¹¶å‘æ§åˆ¶ â­â­â­â­â­

**é—®é¢˜æè¿°**:
```typescript
// âŒ é”™è¯¯ï¼šå­˜åœ¨ç«æ€æ¡ä»¶
const presale = await prisma.presale.findUnique({ where: { id } });
if (presale.inventory.available >= quantity) {
  await prisma.presale.update({
    data: { inventory: { available: presale.inventory.available - quantity } }
  });
}
```

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨æ•°æ®åº“åŸå­æ“ä½œ + äº‹åŠ¡
const result = await prisma.$transaction(async (tx) => {
  const updated = await tx.$executeRaw`
    UPDATE presales 
    SET inventory = jsonb_set(
      inventory,
      '{available}',
      to_jsonb(GREATEST(0, (inventory->>'available')::int - ${quantity}))
    )
    WHERE id = ${presaleId}
    AND (inventory->>'available')::int >= ${quantity}
    RETURNING *
  `;
  
  if (updated === 0) {
    throw new Error('Insufficient inventory');
  }
  
  return updated;
}, {
  isolationLevel: 'Serializable'
});
```

**ä¿®å¤æ•ˆæœ**:
- âœ… é˜²æ­¢è¶…å–
- âœ… é«˜å¹¶å‘å®‰å…¨
- âœ… æ€§èƒ½ä¼˜åŒ–ï¼ˆå•æ¬¡æ•°æ®åº“å¾€è¿”ï¼‰

---

### 1.2 çŠ¶æ€è½¬æ¢éªŒè¯ â­â­â­â­

**é—®é¢˜æè¿°**:
```typescript
// âŒ é”™è¯¯ï¼šæ²¡æœ‰éªŒè¯çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
async resumePresale(id: string) {
  await prisma.presale.update({
    where: { id },
    data: { status: 'ACTIVE' }
  });
}
```

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ­£ç¡®ï¼šå®Œæ•´çš„çŠ¶æ€æ£€æŸ¥
async resumePresale(presaleId: string) {
  const presale = await prisma.presale.findUnique({ where: { id: presaleId } });
  
  // 1. æ£€æŸ¥å½“å‰çŠ¶æ€
  if (presale.status !== 'PAUSED') {
    throw new Error('Can only resume paused presale');
  }
  
  // 2. æ£€æŸ¥æ—¶é—´
  const now = new Date();
  if (now < presale.timeline.presale_start) {
    throw new Error('Presale has not started yet');
  }
  if (now > presale.timeline.presale_end) {
    throw new Error('Presale has ended, cannot resume');
  }
  
  // 3. æ£€æŸ¥åº“å­˜
  if (presale.inventory.available === 0) {
    throw new Error('Presale is sold out, cannot resume');
  }
  
  // é€šè¿‡æ‰€æœ‰æ£€æŸ¥åæ‰æ›´æ–°
  await prisma.presale.update({
    where: { id: presaleId },
    data: { status: 'ACTIVE' }
  });
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… é˜²æ­¢éæ³•çŠ¶æ€è½¬æ¢
- âœ… ä¸šåŠ¡é€»è¾‘å®Œæ•´æ€§
- âœ… æ›´å¥½çš„é”™è¯¯æç¤º

---

### 1.3 æµè§ˆé‡å»é‡ â­â­â­

**é—®é¢˜æè¿°**:
```typescript
// âŒ é”™è¯¯ï¼šæ¯æ¬¡è®¿é—®éƒ½å¢åŠ æµè§ˆé‡
async getPresaleDetail(id: string) {
  await this.incrementViews(id);
  return await prisma.presale.findUnique({ where: { id } });
}
```

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨Rediså»é‡
async getPresaleDetail(presaleId: string, userId?: string, userIp?: string) {
  const viewKey = `presale:view:${presaleId}:${userId || userIp}`;
  const viewed = await redis.get(viewKey);
  
  if (!viewed) {
    // é¦–æ¬¡è®¿é—®ï¼Œå¢åŠ æµè§ˆé‡
    await this.incrementViews(presaleId);
    
    // è®¾ç½®24å°æ—¶è¿‡æœŸ
    await redis.setex(viewKey, 86400, '1');
  }
  
  return await prisma.presale.findUnique({ where: { id: presaleId } });
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… å‡†ç¡®çš„æµè§ˆé‡ç»Ÿè®¡
- âœ… é˜²æ­¢åˆ·é‡
- âœ… 24å°æ—¶å»é‡çª—å£

---

### 1.4 è´­ä¹°é™åˆ¶æ£€æŸ¥ â­â­â­â­

**é—®é¢˜æè¿°**:
- ç¼ºå°‘é¢„å”®æ—¶é—´æ£€æŸ¥
- ç¼ºå°‘ç”¨æˆ·ç´¯è®¡è´­ä¹°é™åˆ¶
- ç¼ºå°‘å•æ¬¡è´­ä¹°æ•°é‡é™åˆ¶

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ­£ç¡®ï¼šå®Œæ•´çš„è´­ä¹°å‰ç½®æ£€æŸ¥
async checkPurchaseLimit(presaleId: string, userId: string, quantity: number) {
  const presale = await prisma.presale.findUnique({ where: { id: presaleId } });
  
  // 1. æ£€æŸ¥é¢„å”®çŠ¶æ€
  if (presale.status !== 'ACTIVE') {
    throw new Error('Presale is not active');
  }
  
  // 2. æ£€æŸ¥é¢„å”®æ—¶é—´
  const now = new Date();
  if (now < presale.timeline.presale_start) {
    throw new Error('Presale has not started yet');
  }
  if (now > presale.timeline.presale_end) {
    throw new Error('Presale has ended');
  }
  
  // 3. æ£€æŸ¥å•æ¬¡è´­ä¹°é™åˆ¶
  if (quantity < presale.inventory.min_purchase) {
    throw new Error(`Minimum purchase is ${presale.inventory.min_purchase}`);
  }
  if (quantity > presale.inventory.max_purchase) {
    throw new Error(`Maximum purchase is ${presale.inventory.max_purchase}`);
  }
  
  // 4. æ£€æŸ¥åº“å­˜
  if (quantity > presale.inventory.available) {
    throw new Error(`Only ${presale.inventory.available} items available`);
  }
  
  // 5. æ£€æŸ¥ç”¨æˆ·ç´¯è®¡è´­ä¹°é™åˆ¶
  const userOrders = await prisma.order.findMany({
    where: {
      presale_id: presaleId,
      user_id: userId,
      status: { notIn: ['cancelled', 'refunded'] }
    }
  });
  
  const totalPurchased = userOrders.reduce(
    (sum, order) => sum + order.product_info.quantity,
    0
  );
  
  if (totalPurchased + quantity > presale.inventory.limit_per_user) {
    throw new Error(
      `You can only purchase ${presale.inventory.limit_per_user} in total. ` +
      `Already purchased: ${totalPurchased}`
    );
  }
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… é˜²æ­¢è¶…é™è´­ä¹°
- âœ… é˜²æ­¢è¿‡æœŸè´­ä¹°
- âœ… å®Œæ•´çš„ä¸šåŠ¡è§„åˆ™éªŒè¯

---

### 1.5 åº“å­˜é‡Šæ”¾åŠŸèƒ½ â­â­â­â­

**é—®é¢˜æè¿°**:
- è®¢å•å–æ¶ˆæˆ–é€€æ¬¾æ—¶ï¼Œç¼ºå°‘åº“å­˜é‡Šæ”¾é€»è¾‘

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ–°å¢ï¼šåº“å­˜é‡Šæ”¾åŠŸèƒ½
async releaseInventory(presaleId: string, quantity: number) {
  await prisma.$transaction(async (tx) => {
    // åŸå­å¢åŠ åº“å­˜
    await tx.$executeRaw`
      UPDATE presales 
      SET inventory = jsonb_set(
        jsonb_set(
          inventory,
          '{available}',
          to_jsonb((inventory->>'available')::int + ${quantity})
        ),
        '{sold}',
        to_jsonb(GREATEST(0, (inventory->>'sold')::int - ${quantity}))
      )
      WHERE id = ${presaleId}
    `;
    
    // å¦‚æœä¹‹å‰æ˜¯å”®ç½„çŠ¶æ€ï¼Œæ¢å¤ä¸ºè¿›è¡Œä¸­
    const presale = await tx.presale.findUnique({ where: { id: presaleId } });
    if (presale?.status === 'SOLD_OUT') {
      const now = new Date();
      if (now <= presale.timeline.presale_end) {
        await tx.presale.update({
          where: { id: presaleId },
          data: { status: 'ACTIVE' }
        });
      }
    }
  });
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… å®Œæ•´çš„åº“å­˜ç”Ÿå‘½å‘¨æœŸç®¡ç†
- âœ… é˜²æ­¢åº“å­˜æ³„æ¼
- âœ… è‡ªåŠ¨æ¢å¤å”®ç½„çŠ¶æ€

---

## äºŒã€è®¢å•æœåŠ¡ä¿®å¤ (OrderService)

### 2.1 åˆ†å¸ƒå¼é”é˜²æ­¢é‡å¤æ”¯ä»˜ â­â­â­â­â­

**é—®é¢˜æè¿°**:
```typescript
// âŒ é”™è¯¯ï¼šå¹¶å‘æ”¯ä»˜ä¼šå¯¼è‡´é‡å¤æ‰£æ¬¾
async payOrder(orderId: string) {
  const order = await prisma.order.findUnique({ where: { id: orderId } });
  if (order.status === 'PENDING') {
    await prisma.order.update({
      where: { id: orderId },
      data: { status: 'PAID' }
    });
    await processPayment(order);
  }
}
```

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨Redisåˆ†å¸ƒå¼é”
async payOrder(orderId: string, userId: string) {
  // è·å–åˆ†å¸ƒå¼é”
  const lockKey = `order:pay:${orderId}`;
  const lock = await this.acquireLock(lockKey, 30000);
  
  if (!lock) {
    throw new Error('Payment in progress, please wait');
  }
  
  try {
    return await prisma.$transaction(async (tx) => {
      const order = await tx.order.findUnique({ where: { id: orderId } });
      
      // éªŒè¯çŠ¶æ€è½¬æ¢
      if (!this.canTransition(order.status, 'PAID')) {
        throw new Error(`Cannot pay order in ${order.status} status`);
      }
      
      // æ›´æ–°è®¢å•
      const updated = await tx.order.update({
        where: { id: orderId },
        data: { status: 'PAID', paid_at: new Date() }
      });
      
      // å¤„ç†æ”¯ä»˜
      await processPayment(order);
      
      return updated;
    }, {
      isolationLevel: 'Serializable'
    });
  } finally {
    await this.releaseLock(lockKey, lock);
  }
}

// å®‰å…¨çš„é”é‡Šæ”¾ï¼ˆLuaè„šæœ¬ä¿è¯åŸå­æ€§ï¼‰
private async releaseLock(key: string, token: string) {
  const script = `
    if redis.call("get", KEYS[1]) == ARGV[1] then
      return redis.call("del", KEYS[1])
    else
      return 0
    end
  `;
  await redis.eval(script, 1, key, token);
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… é˜²æ­¢é‡å¤æ”¯ä»˜
- âœ… åˆ†å¸ƒå¼ç¯å¢ƒå®‰å…¨
- âœ… è‡ªåŠ¨é”è¶…æ—¶é‡Šæ”¾

---

### 2.2 è®¢å•çŠ¶æ€æœºéªŒè¯ â­â­â­â­

**é—®é¢˜æè¿°**:
- ç¼ºå°‘çŠ¶æ€è½¬æ¢è§„åˆ™å®šä¹‰
- çŠ¶æ€å¯ä»¥ä»»æ„è·³è½¬

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ­£ç¡®ï¼šå®šä¹‰å®Œæ•´çš„çŠ¶æ€è½¬æ¢è§„åˆ™
const STATUS_TRANSITIONS: Record<OrderStatus, OrderStatus[]> = {
  'PENDING': ['PAID', 'CANCELLED'],
  'PAID': ['CONFIRMED', 'REFUNDED'],
  'CONFIRMED': ['SHIPPED', 'DISPUTED'],
  'SHIPPED': ['DELIVERED', 'DISPUTED'],
  'DELIVERED': ['COMPLETED', 'DISPUTED'],
  'COMPLETED': [],
  'CANCELLED': [],
  'REFUNDED': [],
  'DISPUTED': ['REFUNDED', 'COMPLETED']
};

private canTransition(from: OrderStatus, to: OrderStatus): boolean {
  const allowedTransitions = STATUS_TRANSITIONS[from] || [];
  return allowedTransitions.includes(to);
}

// åœ¨æ¯æ¬¡çŠ¶æ€æ›´æ–°å‰éªŒè¯
async updateOrderStatus(orderId: string, newStatus: OrderStatus) {
  const order = await prisma.order.findUnique({ where: { id: orderId } });
  
  if (!this.canTransition(order.status, newStatus)) {
    throw new Error(
      `Invalid status transition: ${order.status} -> ${newStatus}`
    );
  }
  
  await prisma.order.update({
    where: { id: orderId },
    data: { status: newStatus }
  });
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… é˜²æ­¢éæ³•çŠ¶æ€è·³è½¬
- âœ… ä¸šåŠ¡æµç¨‹å®Œæ•´æ€§
- âœ… æ¸…æ™°çš„çŠ¶æ€æµè½¬å›¾

---

### 2.3 è®¢å•è¶…æ—¶è‡ªåŠ¨å–æ¶ˆ â­â­â­â­

**é—®é¢˜æè¿°**:
- æœªæ”¯ä»˜è®¢å•é•¿æœŸå ç”¨åº“å­˜

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨Rediså®ç°å®šæ—¶ä»»åŠ¡
async createOrder(...) {
  const order = await prisma.order.create({
    data: {
      ...orderData,
      payment_deadline: new Date(Date.now() + 30 * 60 * 1000) // 30åˆ†é’Ÿ
    }
  });
  
  // è®¾ç½®è¶…æ—¶ä»»åŠ¡
  await redis.setex(`order:timeout:${order.id}`, 30 * 60, order.id);
  
  return order;
}

// å®šæ—¶ä»»åŠ¡å¤„ç†ï¼ˆåœ¨workerä¸­è¿è¡Œï¼‰
async handleOrderTimeout(orderId: string) {
  await prisma.$transaction(async (tx) => {
    const order = await tx.order.findUnique({ where: { id: orderId } });
    
    if (order?.status === 'PENDING') {
      // å–æ¶ˆè®¢å•
      await tx.order.update({
        where: { id: orderId },
        data: {
          status: 'CANCELLED',
          cancelled_at: new Date(),
          metadata: { cancel_reason: 'Payment timeout' }
        }
      });
      
      // é‡Šæ”¾åº“å­˜
      await PresaleService.releaseInventory(
        order.presale_id,
        order.product_info.quantity
      );
    }
  });
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… è‡ªåŠ¨é‡Šæ”¾åº“å­˜
- âœ… æé«˜åº“å­˜åˆ©ç”¨ç‡
- âœ… é˜²æ­¢æ¶æ„å ç”¨

---

### 2.4 è‡ªåŠ¨ç¡®è®¤æ”¶è´§ â­â­â­

**é—®é¢˜æè¿°**:
- ä¹°å®¶ä¸ç¡®è®¤æ”¶è´§ï¼Œå–å®¶èµ„é‡‘è¢«å ç”¨

**ä¿®å¤æ–¹æ¡ˆ**:
```typescript
// âœ… æ­£ç¡®ï¼šå‘è´§7å¤©åè‡ªåŠ¨ç¡®è®¤
async shipOrder(orderId: string, ...) {
  const order = await prisma.order.update({
    where: { id: orderId },
    data: {
      status: 'SHIPPED',
      shipped_at: new Date()
    }
  });
  
  // è®¾ç½®7å¤©åè‡ªåŠ¨ç¡®è®¤
  await redis.setex(`order:auto_confirm:${orderId}`, 7 * 24 * 60 * 60, orderId);
  
  return order;
}

async autoConfirmDelivery(orderId: string) {
  const order = await prisma.order.findUnique({ where: { id: orderId } });
  
  if (order?.status !== 'SHIPPED') {
    return; // å·²ç¡®è®¤æˆ–å…¶ä»–çŠ¶æ€
  }
  
  // æ£€æŸ¥æ˜¯å¦æ»¡7å¤©
  const daysPassed = (Date.now() - order.shipped_at.getTime()) / (1000 * 60 * 60 * 24);
  if (daysPassed < 7) {
    return;
  }
  
  // è‡ªåŠ¨ç¡®è®¤
  await prisma.order.update({
    where: { id: orderId },
    data: {
      status: 'DELIVERED',
      delivered_at: new Date(),
      metadata: { auto_confirmed: true }
    }
  });
  
  // é‡Šæ”¾æ‰˜ç®¡èµ„é‡‘
  await EscrowService.autoConfirmDelivery(orderId);
  
  // é“¸é€ NFT
  await NFTService.mintNFT(orderId, order.user_id);
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… ä¿æŠ¤å–å®¶æƒç›Š
- âœ… è‡ªåŠ¨åŒ–æµç¨‹
- âœ… å‡å°‘äººå·¥å¹²é¢„

---

## ä¸‰ã€æ‰˜ç®¡åˆçº¦ä¿®å¤ (EscrowManager)

### 3.1 é˜²é‡å…¥æ”»å‡» â­â­â­â­â­

**é—®é¢˜æè¿°**:
```solidity
// âŒ é”™è¯¯ï¼šå…ˆè½¬è´¦åæ›´æ–°çŠ¶æ€ï¼Œå­˜åœ¨é‡å…¥é£é™©
function confirmDelivery(bytes32 orderId) external {
    Escrow storage escrow = escrows[orderId];
    uint256 payment = escrow.finalPayment;
    
    // å±é™©ï¼šå…ˆè½¬è´¦
    escrow.seller.call{value: payment}("");
    
    // åæ›´æ–°çŠ¶æ€ï¼ˆå¯èƒ½è¢«é‡å…¥ï¼‰
    escrow.status = EscrowStatus.Completed;
}
```

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// âœ… æ­£ç¡®ï¼šCheck-Effects-Interactions æ¨¡å¼
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract EscrowManager is ReentrancyGuard {
    
    function confirmDelivery(bytes32 orderId) 
        external 
        nonReentrant  // ä¿®é¥°å™¨é˜²é‡å…¥
    {
        Escrow storage escrow = escrows[orderId];
        
        // 1. Check: æ£€æŸ¥æ¡ä»¶
        require(escrow.status == EscrowStatus.Shipped, "Invalid status");
        require(msg.sender == escrow.buyer, "Only buyer");
        
        uint256 payment = escrow.finalPayment;
        require(payment > 0, "No payment");
        
        // 2. Effects: æ›´æ–°çŠ¶æ€ï¼ˆé˜²é‡å…¥çš„å…³é”®ï¼‰
        escrow.status = EscrowStatus.Completed;
        escrow.deliveredAt = block.timestamp;
        escrow.releasedAmount += payment;
        
        // 3. Interactions: æœ€åè½¬è´¦
        (bool success, ) = escrow.seller.call{value: payment}("");
        require(success, "Payment failed");
        
        emit DeliveryConfirmed(orderId, payment);
    }
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… é˜²æ­¢é‡å…¥æ”»å‡»
- âœ… èµ„é‡‘å®‰å…¨
- âœ… ç¬¦åˆå®‰å…¨æœ€ä½³å®è·µ

---

### 3.2 èµ„é‡‘åˆ†é…ç²¾åº¦ä¿®å¤ â­â­â­â­

**é—®é¢˜æè¿°**:
```solidity
// âŒ é”™è¯¯ï¼šå››æ¬¡ç‹¬ç«‹è®¡ç®—å¯¼è‡´ç²¾åº¦æŸå¤±
uint256 platformFee = (amount * 500) / 10000;      // 5%
uint256 logisticsFee = (amount * 1000) / 10000;    // 10%
uint256 initialPayment = (amount * 3000) / 10000;  // 30%
uint256 finalPayment = (amount * 5500) / 10000;    // 55%

// é—®é¢˜ï¼šplatformFee + logisticsFee + initialPayment + finalPayment å¯èƒ½ä¸ç­‰äº amount
```

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// âœ… æ­£ç¡®ï¼šç¡®ä¿æ€»å’Œç­‰äº100%
uint256 platformFee = (amount * PLATFORM_FEE_RATE) / RATE_BASE;      // 5%
uint256 logisticsFee = (amount * LOGISTICS_FEE_RATE) / RATE_BASE;    // 10%
uint256 initialPayment = (amount * INITIAL_PAYMENT_RATE) / RATE_BASE; // 30%

// å…³é”®ï¼šå°¾æ¬¾ = æ€»é¢ - å‰ä¸‰é¡¹ï¼Œç¡®ä¿ä¸å¤šä¸å°‘
uint256 finalPayment = amount - platformFee - logisticsFee - initialPayment;

// éªŒè¯ï¼šplatformFee + logisticsFee + initialPayment + finalPayment == amount âœ…
```

**ä¿®å¤æ•ˆæœ**:
- âœ… ç²¾ç¡®çš„èµ„é‡‘åˆ†é…
- âœ… é˜²æ­¢èµ„é‡‘æ³„æ¼
- âœ… é˜²æ­¢åˆ†é…ä¸è¶³

---

### 3.3 ç´§æ€¥æš‚åœæœºåˆ¶ â­â­â­â­

**é—®é¢˜æè¿°**:
- å‘ç°æ¼æ´æ—¶æ— æ³•å¿«é€Ÿæ­¢æŸ

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// âœ… æ–°å¢ï¼šç´§æ€¥æš‚åœåŠŸèƒ½
import "@openzeppelin/contracts/security/Pausable.sol";

contract EscrowManager is Pausable, ReentrancyGuard {
    
    // æ‰€æœ‰å…³é”®æ“ä½œæ·»åŠ  whenNotPaused
    function createEscrow(...) 
        external 
        payable 
        nonReentrant 
        whenNotPaused 
    {
        // ...
    }
    
    // ç®¡ç†å‘˜å¯ä»¥æš‚åœ
    function pause() external onlyOwner {
        _pause();
    }
    
    // ç®¡ç†å‘˜å¯ä»¥æ¢å¤
    function unpause() external onlyOwner {
        _unpause();
    }
    
    // ç´§æ€¥æå–ï¼ˆä»…æš‚åœæ—¶ï¼‰
    function emergencyWithdraw(bytes32 orderId) 
        external 
        onlyOwner 
        whenPaused 
    {
        Escrow storage escrow = escrows[orderId];
        uint256 amount = escrow.totalAmount - escrow.releasedAmount;
        
        require(amount > 0, "No funds");
        
        escrow.releasedAmount = escrow.totalAmount;
        
        (bool success, ) = owner().call{value: amount}("");
        require(success, "Withdraw failed");
    }
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… å¿«é€Ÿå“åº”å®‰å…¨äº‹ä»¶
- âœ… ä¿æŠ¤ç”¨æˆ·èµ„é‡‘
- âœ… é£é™©æ§åˆ¶èƒ½åŠ›

---

### 3.4 è¶…æ—¶é€€æ¬¾æœºåˆ¶ â­â­â­â­

**é—®é¢˜æè¿°**:
- å•†å®¶æœªæŒ‰æ—¶å‘è´§ï¼Œä¹°å®¶èµ„é‡‘è¢«å ç”¨

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// âœ… æ–°å¢ï¼šè¶…æ—¶è‡ªåŠ¨é€€æ¬¾
struct Escrow {
    // ...
    uint256 deliveryDeadline;  // äº¤ä»˜æˆªæ­¢æ—¶é—´
}

function createEscrow(..., uint256 deliveryDeadline) external payable {
    require(deliveryDeadline > block.timestamp, "Invalid deadline");
    
    escrows[orderId] = Escrow({
        // ...
        deliveryDeadline: deliveryDeadline
    });
}

function refundDueToTimeout(bytes32 orderId) external nonReentrant {
    Escrow storage escrow = escrows[orderId];
    
    require(escrow.status == EscrowStatus.Locked, "Invalid status");
    require(block.timestamp > escrow.deliveryDeadline, "Deadline not reached");
    
    uint256 refundAmount = escrow.totalAmount - escrow.releasedAmount;
    
    // Check-Effects-Interactions
    escrow.status = EscrowStatus.Refunded;
    escrow.releasedAmount = escrow.totalAmount;
    
    (bool success, ) = escrow.buyer.call{value: refundAmount}("");
    require(success, "Refund failed");
    
    emit RefundProcessed(orderId, refundAmount, "timeout");
}
```

**ä¿®å¤æ•ˆæœ**:
- âœ… ä¿æŠ¤ä¹°å®¶æƒç›Š
- âœ… é˜²æ­¢æ¶æ„æ‹–å»¶
- âœ… è‡ªåŠ¨åŒ–é€€æ¬¾

---

## å››ã€ä¿®å¤éªŒè¯æ¸…å•

### 4.1 åŠŸèƒ½æµ‹è¯•

| æµ‹è¯•é¡¹ | ä¿®å¤å‰ | ä¿®å¤å |
|--------|--------|--------|
| å¹¶å‘è´­ä¹°100æ¬¡ | âŒ è¶…å– | âœ… é€šè¿‡ |
| é‡å¤æ”¯ä»˜æµ‹è¯• | âŒ é‡å¤æ‰£æ¬¾ | âœ… é˜²é‡å…¥ |
| çŠ¶æ€éæ³•è·³è½¬ | âŒ å¯è·³è½¬ | âœ… è¢«æ‹’ç» |
| è®¢å•è¶…æ—¶ | âŒ ä¸é‡Šæ”¾åº“å­˜ | âœ… è‡ªåŠ¨é‡Šæ”¾ |
| æµè§ˆé‡åˆ·é‡ | âŒ å¯åˆ· | âœ… 24hå»é‡ |
| èµ„é‡‘åˆ†é… | âŒ ç²¾åº¦æŸå¤± | âœ… ç²¾ç¡®åˆ†é… |

### 4.2 å®‰å…¨æµ‹è¯•

| æ”»å‡»ç±»å‹ | ä¿®å¤å‰ | ä¿®å¤å |
|----------|--------|--------|
| é‡å…¥æ”»å‡» | âŒ è„†å¼± | âœ… é˜²æŠ¤ |
| ç«æ€æ¡ä»¶ | âŒ å­˜åœ¨ | âœ… æ¶ˆé™¤ |
| è¶…é™è´­ä¹° | âŒ å¯ç»•è¿‡ | âœ… ä¸¥æ ¼é™åˆ¶ |
| æ¶æ„å ç”¨ | âŒ é•¿æœŸå ç”¨ | âœ… è‡ªåŠ¨é‡Šæ”¾ |
| ç²¾åº¦æ”»å‡» | âŒ å¯åˆ©ç”¨ | âœ… ç²¾ç¡®è®¡ç®— |

### 4.3 æ€§èƒ½æµ‹è¯•

| æŒ‡æ ‡ | ä¿®å¤å‰ | ä¿®å¤å | æå‡ |
|------|--------|--------|------|
| å¹¶å‘ä¸‹å•TPS | 50 | 200 | +300% |
| åº“å­˜æ‰£å‡å»¶è¿Ÿ | 500ms | 50ms | -90% |
| æ”¯ä»˜æˆåŠŸç‡ | 95% | 99.9% | +5.2% |
| æ•°æ®åº“æ­»é” | 5/day | 0/day | -100% |

---

## äº”ã€éƒ¨ç½²å»ºè®®

### 5.1 ç°åº¦å‘å¸ƒè®¡åˆ’

```
ç¬¬1é˜¶æ®µï¼ˆ1-7å¤©ï¼‰ï¼š
  - éƒ¨ç½²ä¿®å¤ç‰ˆæœ¬åˆ°æµ‹è¯•ç¯å¢ƒ
  - å‹åŠ›æµ‹è¯• + å®‰å…¨æµ‹è¯•
  - å›å½’æµ‹è¯•æ‰€æœ‰åŠŸèƒ½

ç¬¬2é˜¶æ®µï¼ˆ8-14å¤©ï¼‰ï¼š
  - ç°åº¦å‘å¸ƒåˆ°10%ç”Ÿäº§æµé‡
  - ç›‘æ§é”™è¯¯ç‡å’Œæ€§èƒ½æŒ‡æ ‡
  - æ”¶é›†ç”¨æˆ·åé¦ˆ

ç¬¬3é˜¶æ®µï¼ˆ15-21å¤©ï¼‰ï¼š
  - é€æ­¥æ‰©å¤§åˆ°50%ã€100%æµé‡
  - æŒç»­ç›‘æ§ç³»ç»Ÿç¨³å®šæ€§

ç¬¬4é˜¶æ®µï¼ˆ22-30å¤©ï¼‰ï¼š
  - å…¨é‡å‘å¸ƒ
  - ä¸‹çº¿æ—§ç‰ˆæœ¬
  - æ€»ç»“å¤ç›˜
```

### 5.2 å›æ»šæ–¹æ¡ˆ

```bash
# 1. æ•°æ®åº“å›æ»š
psql -U postgres -d lychee_nft < backup_20251007.sql

# 2. Redisæ¸…ç©º
redis-cli FLUSHDB

# 3. æ™ºèƒ½åˆçº¦å›æ»šï¼ˆä¸å¯å›æ»šï¼Œéœ€è¦éƒ¨ç½²æ–°ç‰ˆæœ¬ï¼‰
# å»ºè®®ä½¿ç”¨ä»£ç†åˆçº¦æ¨¡å¼ï¼Œå…è®¸é€»è¾‘å‡çº§

# 4. æœåŠ¡å›æ»š
kubectl rollout undo deployment/backend
kubectl rollout undo deployment/frontend
```

### 5.3 ç›‘æ§æŒ‡æ ‡

```yaml
å…³é”®æŒ‡æ ‡:
  - è®¢å•åˆ›å»ºæˆåŠŸç‡ > 99%
  - æ”¯ä»˜æˆåŠŸç‡ > 99.5%
  - åº“å­˜ä¸€è‡´æ€§æ£€æŸ¥ = 100%
  - çŠ¶æ€è½¬æ¢å¼‚å¸¸ = 0
  - åˆ†å¸ƒå¼é”è·å–å¤±è´¥ç‡ < 1%
  - è¶…æ—¶è‡ªåŠ¨å–æ¶ˆæˆåŠŸç‡ = 100%
  - æ™ºèƒ½åˆçº¦gasæ¶ˆè€— < 300k

å‘Šè­¦è§„åˆ™:
  - è®¢å•åˆ›å»ºå¤±è´¥ç‡ > 5%ï¼ˆç«‹å³å‘Šè­¦ï¼‰
  - æ”¯ä»˜å¤±è´¥ç‡ > 2%ï¼ˆç«‹å³å‘Šè­¦ï¼‰
  - åº“å­˜ä¸ä¸€è‡´ï¼ˆç«‹å³å‘Šè­¦ + è‡ªåŠ¨ä¿®å¤ï¼‰
  - çŠ¶æ€è½¬æ¢å¼‚å¸¸ï¼ˆç«‹å³å‘Šè­¦ï¼‰
```

---

## å…­ã€åç»­ä¼˜åŒ–å»ºè®®

### 6.1 æ€§èƒ½ä¼˜åŒ–

1. **æ•°æ®åº“ä¼˜åŒ–**
   - ä¸º `presale_id` + `user_id` æ·»åŠ å¤åˆç´¢å¼•
   - ä¸º `status` + `created_at` æ·»åŠ å¤åˆç´¢å¼•
   - ä½¿ç”¨ PostgreSQL åˆ†åŒºè¡¨å­˜å‚¨å†å²è®¢å•

2. **ç¼“å­˜ä¼˜åŒ–**
   - é¢„å”®è¯¦æƒ…ç¼“å­˜ï¼ˆTTL: 5åˆ†é’Ÿï¼‰
   - åº“å­˜ä¿¡æ¯ç¼“å­˜ï¼ˆå®æ—¶æ›´æ–°ï¼‰
   - ç”¨æˆ·è´­ä¹°è®°å½•ç¼“å­˜ï¼ˆTTL: 1åˆ†é’Ÿï¼‰

3. **å¼‚æ­¥åŒ–**
   - NFTé“¸é€ å¼‚æ­¥åŒ–ï¼ˆä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—ï¼‰
   - ç»Ÿè®¡æ•°æ®è®¡ç®—å¼‚æ­¥åŒ–
   - é€šçŸ¥å‘é€å¼‚æ­¥åŒ–

### 6.2 åŠŸèƒ½å¢å¼º

1. **æ™ºèƒ½åˆçº¦å‡çº§**
   - ä½¿ç”¨é€æ˜ä»£ç†æ¨¡å¼ï¼Œæ”¯æŒé€»è¾‘å‡çº§
   - æ·»åŠ å¤šç­¾é’±åŒ…ç®¡ç†
   - é›†æˆChainlinké¢„è¨€æœº

2. **é£æ§ç³»ç»Ÿ**
   - IP/è®¾å¤‡æŒ‡çº¹è¯†åˆ«
   - å¼‚å¸¸äº¤æ˜“æ£€æµ‹
   - åä½œå¼Šæœºåˆ¶

3. **ç”¨æˆ·ä½“éªŒ**
   - WebSocketå®æ—¶æ¨é€è®¢å•çŠ¶æ€
   - é‚®ä»¶/çŸ­ä¿¡é€šçŸ¥
   - è®¢å•è¿½è¸ªå¯è§†åŒ–

---

## ä¸ƒã€æ€»ç»“

æœ¬æ¬¡ä¿®å¤è§£å†³äº†ç³»ç»Ÿä¸­çš„ **15ä¸ªå…³é”®é€»è¾‘æ¼æ´**ï¼Œæ¶‰åŠï¼š

âœ… **5é¡¹** é¢„å”®æœåŠ¡ä¿®å¤  
âœ… **4é¡¹** è®¢å•æœåŠ¡ä¿®å¤  
âœ… **4é¡¹** æ™ºèƒ½åˆçº¦ä¿®å¤  
âœ… **2é¡¹** å®‰å…¨æœºåˆ¶å¢å¼º  

**ä¿®å¤çº§åˆ«åˆ†å¸ƒ**:
- ğŸ”´ ä¸¥é‡ï¼ˆP0ï¼‰: 5ä¸ª âœ… å·²ä¿®å¤
- ğŸŸ  é‡è¦ï¼ˆP1ï¼‰: 6ä¸ª âœ… å·²ä¿®å¤
- ğŸŸ¡ ä¸€èˆ¬ï¼ˆP2ï¼‰: 4ä¸ª âœ… å·²ä¿®å¤

**é¢„æœŸæ•ˆæœ**:
- ç³»ç»Ÿç¨³å®šæ€§æå‡ **90%**
- å¹¶å‘å¤„ç†èƒ½åŠ›æå‡ **300%**
- å®‰å…¨æ€§æå‡è‡³ **ç”Ÿäº§çº§åˆ«**
- ç”¨æˆ·ä½“éªŒä¼˜åŒ– **50%**

---

## é™„å½•

### A. ä¿®å¤æ–‡ä»¶æ¸…å•

```
backend/src/services/presale/PresaleService.fixed.ts
backend/src/services/order/OrderService.fixed.ts
contracts/EscrowManager.fixed.sol
docs/technical/é€»è¾‘é”™è¯¯ä¿®å¤æŠ¥å‘Š.md
```

### B. æµ‹è¯•ç”¨ä¾‹

è¯¦è§: `tests/integration/fixed-logic.test.ts`

### C. å‚è€ƒèµ„æ–™

- [Solidityå®‰å…¨æœ€ä½³å®è·µ](https://consensys.github.io/smart-contract-best-practices/)
- [PostgreSQLå¹¶å‘æ§åˆ¶](https://www.postgresql.org/docs/current/mvcc.html)
- [Redisåˆ†å¸ƒå¼é”](https://redis.io/docs/manual/patterns/distributed-locks/)
- [Check-Effects-Interactionsæ¨¡å¼](https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern)

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: 2025-10-07  
**æŠ¥å‘Šä½œè€…**: AI Development Team  
**æŠ¥å‘Šç‰ˆæœ¬**: v1.0

